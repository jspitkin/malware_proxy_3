# Stage 1 of a malware filtering proxy.
# Written for CS 4480 Computer Networks with Prof. Kobus Van der Merwe
# Last edit: January 28th, 2016
# Author: Jake Pitkin 
# Repository: https://github.com/jspitkin/malware_proxy_1.git

import socket
import select
import sys
from urlparse import urlparse
import multiprocessing
import hashlib

def main():
    if len(sys.argv) == 1:
        print 'Please enter a port number as a command line argument.'
        return

    serverPort = int(sys.argv[1])
    serverAddress = 'localhost'

    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    print 'Got a socket:', serverSocket.fileno()

    serverSocket.bind((serverAddress,serverPort))
    print 'Bound to:', serverSocket.getsockname()

    serverSocket.listen(1)

    input = [serverSocket]

    while 1:

        inputready,outputready,exceptready = select.select(input,[],[])

        for s in inputready:

            if s == serverSocket:
                connectionSocket, addr = serverSocket.accept()
                print 'Accepted connection from:', connectionSocket.getpeername()
                input.append(connectionSocket)

            else :
				process = multiprocessing.Process(target=acceptRequest(s))
				process.start()
				input.remove(s)

# Takes in a HTTP response and returns only the payload
# removing any header information
def extractBody(response):
    responseChunks = response.split('\r\n\r\n')
    responsePayload = ''
    for chunk in responseChunks[1:]:
        responsePayload += chunk
    return responsePayload

# Point of entry method for verifying an HTTP response
# Return:
#   1 - Content is not registered in team cymru's hash
#   0 - Content contains malware
def verifyContent(response):
    # extract the payload from the HTTP response
    responsePayload = extractBody(response)
    # hash the payload
    payloadHash = hashlib.md5(responsePayload).hexdigest()
    # forward the hash to team cymru
    request = 'whois -h hash.cymru.com ' + payloadHash + '\r\n'
    remoteSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remoteSocket.connect(('hash.cymru.com',43))
    remoteSocket.send(request)
    cymruResponse = remoteSocket.recv(4096)
    # search for NO_DATA in the response from team cymru
    cymruResponseChunks = cymruResponse.split()
    for chunk in cymruResponseChunks:
        if chunk == 'NO_DATA':
            return 1
    return 0

# Generates a simple HTML page indicating the requested
# content contains malware.
def malwareWarningHTMLPage():
    malwareWebPage = '<!DOCTYPE html>\r\n'
    malwareWebPage += '<html>\r\n'
    malwareWebPage += '\r\n<head><title>WARNING: This Site Contains Malware</title></head>\r\n\r\n'
    malwareWebPage += '<body>\r\n'
    malwareWebPage += '<h1>This site comtains malware</h1>\r\n'
    malwareWebPage += '<h2>Lucky for you, my malware proxy saved your sweet computer :-)</h2>\r\n'
    malwareWebPage += '</body>\r\n'
    malwareWebPage += '</html>\r\n'
    return malwareWebPage

def acceptRequest(socket):
    host = None # host for the request to the remote server
    path = None # path for the request to the remote server
    response400 = 0 # Flag a 400 response should be sent
    response501 = 0 # Flag a 501 response should be sent

    # accept lines until two new line characters are seen
    while 1:
        requestLine = socket.recv(4096)
        print requestLine
        if requestLine == '\r\n':
            break
        # Set 501 flag if non-GET method
        if badMethod(requestLine):
            response501 = 1
        parsedRequest = parseRequest(requestLine)
        # Set 400 flag if invalid request
        if parsedRequest[0]:
            response400 = 1
        # Set host and path from an absolute URI
        if len(parsedRequest) == 3:
            host = parsedRequest[1]
            path = parsedRequest[2]
        # Set host from a Host header
        if len(parsedRequest) == 2:
            host = parsedRequest[1]
    if response501:
        socket.send('HTTP/1.1 501 Not Implemented\n')
    elif response400:
        socket.send('HTTP/1.1 400 Bad request\n')
    elif host is not None and path is not None:
        requestContent = requestPage(path, host)
        malwareFree = verifyContent(requestContent)
        if malwareFree == 0:
            socket.send(malwareWarningHTMLPage())
        elif malwareFree == 1:
            socket.send(requestContent)
            print 'Content from ' + host + 'sent to client.'
    else:
        socket.send('HTTP/1.1 400 Bad request\n')
    socket.close()

# Return:
#   1 - Method was a non-GET method
#   0 - otherwise
def badMethod(request):
    if request == '':
        return 1
    separatedRequest = request.split()
    method = separatedRequest[0]
    if method == 'HEAD' or method == 'POST' or method == 'PUT' or \
       method == 'OPTIONS' or method == 'DELETE' or method == 'TRACE' or \
       method == 'CONNECT': 
        return 1
    return 0

# Return:
#   [0] - 1 if the request is invalid, 0 otherwise
#   [1] - hostname
#   [2] - path
def parseRequest(request):
    if request == '':
        return 1, None
    separatedRequest = request.split()
    if separatedRequest[0] == 'Host:':
        return 0, separatedRequest[1]
    if separatedRequest[0] == 'GET':
        parsedURL = urlparse(separatedRequest[1])
        if parsedURL.hostname is None and parsedURL.path is not None:
            return 0, parsedURL.hostname, parsedURL.path
        if parsedURL.hostname is not None and parsedURL.path is not None:
            return 0, parsedURL.hostname, parsedURL.path
    return 1, None

# Makes a request to the remote server
# Return:
#   The response from the remote server
def requestPage(path, host):
    request = 'GET ' + path + ' HTTP/1.0\n'
    request += 'Host: ' + host + '\n'
    request += 'Connection: close\n\n'
    remoteSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remoteSocket.connect((host,80))
    remoteSocket.send(request)
    content = ""
    contentChunk = None
    while contentChunk != "":
        contentChunk = remoteSocket.recv(4096)
        content += contentChunk
    return content

if __name__ == "__main__":
    main()