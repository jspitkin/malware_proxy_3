# Final state of a malware filtering proxy.
# Written for CS 4480 Computer Networks with Prof. Kobus Van der Merwe
# Last edit: February 21st, 2016
# Author: Jake Pitkin 
# Repository: https://github.com/jspitkin/malware_proxy_3.git

import socket
import select
import sys
from urlparse import urlparse
import multiprocessing
import hashlib

# Server entry point
def main():
    # Close the server if the user doesn't provide a port
    if len(sys.argv) == 1:
        print 'Please enter a port number as a command line argument.'
        return

    serverPort = int(sys.argv[1])
    serverAddress = 'localhost'

    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    print 'Got a socket:', serverSocket.fileno()

    serverSocket.bind((serverAddress,serverPort))
    print 'Bound to:', serverSocket.getsockname()

    serverSocket.listen(1)

    input = [serverSocket]

    while 1:

        inputready,outputready,exceptready = select.select(input,[],[])

        for s in inputready:

            if s == serverSocket:
                connectionSocket, addr = serverSocket.accept()
                print 'Accepted connection from:', connectionSocket.getpeername()
                input.append(connectionSocket)

            else :
				process = multiprocessing.Process(target=acceptRequest(s))
				process.start()
				input.remove(s)

# Takes in a HTTP response and returns only the payload
# removing any header information
def extractBody(response):
    responseChunks = response.split('\r\n\r\n')
    responsePayload = ''
    for chunk in responseChunks[1:]:
        responsePayload += chunk
    return responsePayload

# Point of entry method for verifying an HTTP response
# Return:
#   1 - Content is not registered in team cymru's hash
#   0 - Content contains malware
def verifyContent(response):
    # extract the payload from the HTTP response
    responsePayload = extractBody(response)
    # hash the payload
    payloadHash = hashlib.md5(responsePayload).hexdigest()
    # forward the hash to team cymru
    request = 'whois -h hash.cymru.com ' + payloadHash + '\r\n'
    remoteSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remoteSocket.connect(('hash.cymru.com',43))
    remoteSocket.send(request)
    cymruResponse = remoteSocket.recv(4096)
    # search for NO_DATA in the response from team cymru
    cymruResponseChunks = cymruResponse.split()
    for chunk in cymruResponseChunks:
        if chunk == 'NO_DATA':
            return 1
    return 0

# Generates a simple HTML page indicating the requested
# content contains malware.
def malwareWarningHTMLPage():
    malwareWebPage = '<!DOCTYPE html>\r\n'
    malwareWebPage += '<html>\r\n'
    malwareWebPage += '\r\n<head><title>WARNING: This Site Contains Malware</title></head>\r\n\r\n'
    malwareWebPage += '<body>\r\n'
    malwareWebPage += '<h1>This site comtains malware</h1>\r\n'
    malwareWebPage += '<h2>Lucky for you, my malware proxy saved your sweet computer :-)</h2>\r\n'
    malwareWebPage += '</body>\r\n'
    malwareWebPage += '</html>\r\n'
    return malwareWebPage

def acceptRequest(socket):
    host = None # host for the request to the remote server
    path = None # path for the request to the remote server
    response400 = 0 # Flag a 400 response should be sent
    response501 = 0 # Flag a 501 response should be sent
    requestLines = '' # Build in the request lines

    # accept lines until two new line characters are seen
    # collect all the request lines
    while 1:
        request = socket.recv(4096)
        requestLines += request
        if request == '\r\n':
            break;
        if '\r\n\r\n' in request:
            break;

    requestSplit = requestLines.split('\r\n')
    # iterate through the collected lines and handle them
    for line in requestSplit:
        # Set 501 flag if non-GET method
        if badMethod(line):
            response501 = 1
        wordsInLine = line.split()
        # Collect the host and path for GET lines
        if len(wordsInLine) > 0 and wordsInLine[0] == 'GET':
            parsedURL = urlparse(wordsInLine[1])
            host = parsedURL.hostname
            path = parsedURL.path
        # Collect the host for HOST: lines
        if len(wordsInLine) > 0 and wordsInLine[0] == 'Host:':
            host = wordsInLine[1]
    # Return a 501 Error page for Non-GET requests
    if response501:
        socket.send('HTTP/1.1 501 Not Implemented\n')
    # Process a valid request
    elif host is not None and path is not None:
        requestContent = requestPage(path, host, requestLines)
        # Test the payload for malware
        malwareFree = verifyContent(requestContent)
        # If malware free, server the page. Otherwise, serve warning page
        if malwareFree == 0:
            socket.send(malwareWarningHTMLPage())
        elif malwareFree == 1:
            socket.send(requestContent)
            print 'Content from ' + host + 'sent to client.'
    # If process couldn't be parsed send a 400 Error page
    else:
        socket.send('HTTP/1.1 400 Bad request\n')
    socket.close()

# Return:
#   1 - Method was a non-GET method
#   0 - otherwise
def badMethod(request):
    separatedRequest = request.split()
    if len(separatedRequest) == 0:
        return 0
    method = separatedRequest[0]
    if method == 'HEAD' or method == 'POST' or method == 'PUT' or \
       method == 'OPTIONS' or method == 'DELETE' or method == 'TRACE' or \
       method == 'CONNECT':      
        return 1
    return 0

# Makes a request to the remote server
# Return:
#   The response from the remote server
def requestPage(path, host, request):
    request = 'GET ' + path + ' HTTP/1.0\n'
    request += 'Host: ' + host + '\n'
    request += 'Connection: close\n\n'
    remoteSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remoteSocket.connect((host,80))
    remoteSocket.send(request)
    content = ""
    contentChunk = None
    while contentChunk != "":
        contentChunk = remoteSocket.recv(4096)
        content += contentChunk
    return content

if __name__ == "__main__":
    main()